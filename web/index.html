<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>RACI Explorer Prototype</title>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-sankey@0.12"></script>
    <style>
      :root {
        color-scheme: light;
      }
      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        margin: 2rem;
        background: #f9fafb;
        color: #1f2937;
      }
      h1 {
        margin-top: 0;
      }
      .summary {
        display: flex;
        flex-wrap: wrap;
        gap: 1.5rem;
        margin-bottom: 2rem;
      }
      .summary-card {
        background: #fff;
        border-radius: 10px;
        padding: 1rem 1.5rem;
        box-shadow: 0 4px 12px rgba(15, 23, 42, 0.08);
        min-width: 180px;
      }
      #status-banner {
        margin-bottom: 1rem;
        color: #475569;
      }
      .dataset-section {
        margin-bottom: 2.5rem;
        max-width: 1100px;
        background: #fff;
        border-radius: 12px;
        box-shadow: 0 6px 18px rgba(15, 23, 42, 0.08);
        padding: 1.25rem 1.5rem;
      }
      .dataset-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        align-items: flex-end;
        margin-bottom: 0.75rem;
      }
      .dataset-actions label {
        font-size: 0.85rem;
        color: #334155;
        display: flex;
        flex-direction: column;
        gap: 0.3rem;
      }
      .dataset-actions input[type="file"] {
        font-size: 0.9rem;
      }
      .dataset-actions input[type="text"] {
        padding: 0.35rem 0.5rem;
        border: 1px solid #cbd5f5;
        border-radius: 6px;
        min-width: 160px;
        font-size: 0.95rem;
      }
      .dataset-actions button {
        padding: 0.45rem 0.85rem;
        border: none;
        border-radius: 6px;
        font-size: 0.9rem;
        font-weight: 600;
        cursor: pointer;
        background: #1d4ed8;
        color: #fff;
        box-shadow: 0 2px 6px rgba(37, 99, 235, 0.3);
        transition: transform 0.1s ease, box-shadow 0.1s ease;
      }
      .dataset-actions button.secondary {
        background: #64748b;
        box-shadow: 0 2px 6px rgba(100, 116, 139, 0.25);
      }
      .dataset-actions button:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 10px rgba(37, 99, 235, 0.25);
      }
      .dataset-actions button.secondary:hover {
        box-shadow: 0 4px 10px rgba(100, 116, 139, 0.25);
      }
      .dataset-status {
        font-size: 0.9rem;
        color: #475569;
      }
      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        align-items: center;
        margin-bottom: 1.5rem;
      }
      .controls label {
        display: flex;
        flex-direction: column;
        font-size: 0.85rem;
        color: #334155;
        gap: 0.25rem;
      }
      .controls select {
        min-width: 180px;
        padding: 0.35rem 0.5rem;
        border: 1px solid #cbd5f5;
        border-radius: 6px;
        background: #fff;
        font-size: 0.95rem;
        color: #1f2937;
      }
      #warnings {
        margin-bottom: 2.5rem;
      }
      #warnings-list {
        padding-left: 1.2rem;
      }
      .sankey-section {
        max-width: 1100px;
      }
      .legend {
        display: flex;
        gap: 1rem;
        margin-bottom: 0.75rem;
        flex-wrap: wrap;
      }
      .legend-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.9rem;
        color: #334155;
      }
      .legend-swatch {
        width: 14px;
        height: 14px;
        border-radius: 3px;
      }
      #sankey-placeholder {
        position: relative;
        width: 100%;
        min-height: 460px;
        background: #fff;
        border-radius: 12px;
        box-shadow: 0 6px 18px rgba(15, 23, 42, 0.08);
        padding: 1rem;
        overflow: hidden;
      }
      .dependency-section {
        margin-top: 3rem;
        max-width: 1300px;
      }
      .matrix-section {
        margin-top: 3rem;
        max-width: 1300px;
      }
      #dependency-graph {
        position: relative;
        width: 100%;
        min-height: 520px;
        background: #fff;
        border-radius: 12px;
        box-shadow: 0 6px 18px rgba(15, 23, 42, 0.08);
        padding: 1rem;
        overflow-x: auto;
        overflow-y: hidden;
      }
      .matrix-wrapper {
        background: #fff;
        border-radius: 12px;
        box-shadow: 0 6px 18px rgba(15, 23, 42, 0.08);
        padding: 1rem;
        overflow-x: auto;
      }
      .matrix-table {
        border-collapse: separate;
        border-spacing: 0;
        font-size: 12px;
        width: 100%;
        min-width: 720px;
      }
      .matrix-table th,
      .matrix-table td {
        border: 1px solid #e2e8f0;
        padding: 6px 10px;
        text-align: center;
        white-space: nowrap;
      }
      .matrix-table th {
        background: #f1f5f9;
        font-weight: 600;
        color: #334155;
      }
      .matrix-table th.role-header.highlight {
        background: #dbeafe;
        color: #1d4ed8;
      }
      .matrix-group-row th {
        text-align: left;
        background: #e2e8f0;
        color: #1f2937;
        font-size: 13px;
      }
      .matrix-action-cell {
        text-align: left;
        font-weight: 500;
        max-width: 260px;
        white-space: normal;
      }
      .matrix-row.highlight .matrix-action-cell {
        color: #1d4ed8;
      }
      .matrix-row.dimmed .matrix-action-cell {
        color: #94a3b8;
      }
      .matrix-cell {
        min-width: 64px;
        position: relative;
        font-weight: 600;
        color: #1f2937;
        background: #ffffff;
        transition: opacity 0.2s ease, box-shadow 0.2s ease;
      }
      .matrix-cell.highlight {
        box-shadow: inset 0 0 0 2px rgba(37, 99, 235, 0.7);
        background: #eff6ff;
      }
      .matrix-cell.dimmed {
        opacity: 0.3;
      }
      .matrix-cell.empty {
        color: #94a3b8;
        font-weight: 400;
      }
      .matrix-cell.editing {
        box-shadow: inset 0 0 0 2px rgba(37, 99, 235, 0.85);
        background: #dbeafe;
      }
      .matrix-editor {
        position: absolute;
        z-index: 2000;
        display: none;
        flex-direction: column;
        gap: 0.5rem;
        padding: 0.75rem 0.9rem;
        background: #fff;
        border: 1px solid #cbd5f5;
        border-radius: 10px;
        box-shadow: 0 12px 24px rgba(15, 23, 42, 0.18);
        min-width: 160px;
      }
      .matrix-editor-options {
        display: grid;
        grid-template-columns: repeat(2, auto);
        gap: 0.5rem 1rem;
      }
      .matrix-editor-options label {
        display: flex;
        align-items: center;
        gap: 0.35rem;
        font-size: 0.85rem;
        color: #1f2937;
      }
      .matrix-editor-actions {
        display: flex;
        justify-content: flex-end;
        gap: 0.5rem;
        margin-top: 0.5rem;
      }
      .matrix-editor button {
        padding: 0.35rem 0.75rem;
        border: none;
        border-radius: 6px;
        font-size: 0.85rem;
        font-weight: 600;
        cursor: pointer;
        background: #1d4ed8;
        color: #fff;
        box-shadow: 0 2px 6px rgba(37, 99, 235, 0.3);
        transition: transform 0.1s ease, box-shadow 0.1s ease;
      }
      .matrix-editor button.secondary {
        background: #64748b;
        box-shadow: 0 2px 6px rgba(100, 116, 139, 0.25);
      }
      .matrix-editor button:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 10px rgba(37, 99, 235, 0.25);
      }
      .matrix-editor button.secondary:hover {
        box-shadow: 0 4px 10px rgba(100, 116, 139, 0.25);
      }
      .graph-legend {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        margin-bottom: 0.75rem;
        font-size: 0.9rem;
        color: #334155;
      }
      .activity-node rect {
        stroke: rgba(15, 23, 42, 0.12);
        stroke-width: 1;
      }
      .activity-node.highlight rect {
        stroke: #2563eb;
        stroke-width: 2;
      }
      .activity-node.dimmed rect {
        opacity: 0.35;
      }
      .dependency-edge {
        fill: none;
        opacity: 0.75;
      }
      .dependency-edge.dimmed {
        opacity: 0.25;
      }
      .dependency-headers text.highlight {
        fill: #1d4ed8;
      }
      svg text {
        font-size: 12px;
        fill: #1f2937;
      }
      .node rect {
        stroke: rgba(15, 23, 42, 0.1);
        stroke-width: 1;
      }
    </style>
  </head>
  <body>
    <h1>RACI Explorer Prototype</h1>
    <p id="status-banner">Loading data…</p>
    <section class="summary" id="summary"></section>
    <section id="warnings">
      <h2>Action Warnings</h2>
      <ul id="warnings-list"></ul>
    </section>
    <section class="dataset-section">
      <h2>Dataset Management</h2>
      <div class="dataset-actions">
        <label>
          Load RACI JSON
          <input type="file" id="dataset-upload" accept=".json" />
        </label>
        <button type="button" class="secondary" id="dataset-reset">Reload default</button>
        <label>
          Download filename
          <input type="text" id="dataset-filename" value="raci_matrix" />
        </label>
        <button type="button" id="download-matrix">Download matrix CSV</button>
        <button type="button" id="download-json">Download data JSON</button>
      </div>
      <p class="dataset-status" id="dataset-status">Using default dataset.</p>
    </section>
    <section class="controls">
      <label>
        Role filter
        <select id="role-filter"></select>
      </label>
      <label>
        RACI filter
        <select id="raci-filter">
          <option value="all" selected>All letters</option>
          <option value="R">Responsible (R)</option>
          <option value="A">Accountable (A)</option>
          <option value="C">Consulted (C)</option>
          <option value="I">Informed (I)</option>
        </select>
      </label>
      <label>
        Connection type
        <select id="dependency-type-filter">
          <option value="all" selected>All types</option>
        </select>
      </label>
    </section>
    <section class="sankey-section">
      <h2>Lifecycle Sankey</h2>
      <div id="sankey-legend" class="legend"></div>
      <div id="sankey-placeholder"></div>
    </section>
    <section class="dependency-section">
      <h2>Activity Dependency Graph</h2>
      <div id="dependency-legend" class="graph-legend"></div>
      <div id="dependency-graph"></div>
    </section>
    <section class="matrix-section">
      <h2>Responsibility Matrix</h2>
      <div class="matrix-wrapper">
        <table class="matrix-table" id="responsibility-matrix"></table>
      </div>
    </section>

    <script>
      const STATUS_COLORS = { R: "#f97316", A: "#ef4444", C: "#3b82f6", I: "#16a34a" };
      const NODE_COLORS = { action: "#8b5cf6", role: "#0ea5e9" };
      const EDIT_LETTERS = ["R", "A", "C", "I"];

      let originalData = null;
      let cachedData = null;
      let resizeTimeout = null;
      let actionAssignments = new Map();
      let dependencyTypes = [];
      let dependencyColorScale = null;
      let datasetStatusEl = null;
      let matrixEditor = null;
      let matrixEditorState = null;
      const filters = { role: "all", raci: "all", dependencyType: "all" };

      async function init() {
        const statusEl = document.getElementById("status-banner");
        statusEl.textContent = "Loading data…";
        try {
          const response = await fetch(`../build/raci_enriched.json?t=${Date.now()}`);
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const data = await response.json();
          originalData = data;
          setupDatasetControls();
          applyData(data, { resetFilters: true, statusMessage: "Using default dataset." });
        } catch (error) {
          cachedData = null;
          document.getElementById("sankey-placeholder").textContent = "Unable to display Sankey.";
          document.getElementById("dependency-graph").textContent = "Unable to display dependency graph.";
          statusEl.textContent = "Failed to load data.";
          console.error("Failed to load raci_enriched.json", error);
        }
      }

      function buildActionAssignments(relationships) {
        const map = new Map();
        for (const rel of relationships) {
          if (!map.has(rel.action_id)) {
            map.set(rel.action_id, new Map());
          }
          const roleMap = map.get(rel.action_id);
          if (!roleMap.has(rel.role_id)) {
            roleMap.set(rel.role_id, new Set());
          }
          roleMap.get(rel.role_id).add(rel.raci);
        }
        return map;
      }

      function normalizeData(data) {
        const metricsRaw = data && typeof data.metrics === "object" && data.metrics ? data.metrics : {};
        const activityGroups = data && Array.isArray(data.activity_groups) ? data.activity_groups : [];
        const roles = data && Array.isArray(data.roles) ? data.roles : [];
        const actions = data && Array.isArray(data.actions) ? data.actions : [];
        const relationships = data && Array.isArray(data.relationships) ? data.relationships : [];
        const dependencies = data && Array.isArray(data.activity_dependencies) ? data.activity_dependencies : [];
        const metrics = {
          ...metricsRaw,
          role_summary: Array.isArray(metricsRaw.role_summary) ? metricsRaw.role_summary : [],
          action_warnings: Array.isArray(metricsRaw.action_warnings) ? metricsRaw.action_warnings : [],
          group_summary: metricsRaw.group_summary || {},
          dependency_summary: metricsRaw.dependency_summary || {},
          dependency_warnings: Array.isArray(metricsRaw.dependency_warnings)
            ? metricsRaw.dependency_warnings
            : [],
        };

        return {
          ...data,
          activity_groups: activityGroups,
          roles,
          actions,
          relationships,
          activity_dependencies: dependencies,
          metrics,
        };
      }

      function renderSummary(data) {
        const container = d3.select("#summary");
        container.selectAll("*").remove();

        const metrics = data.metrics || {};
        const roles = metrics.role_summary || [];
        const totalEdges = (data.relationships || []).length;
        const cards = [
          { label: "Lifecycle groups", value: (data.activity_groups || []).length },
          { label: "Actions", value: (data.actions || []).length },
          { label: "Relationships", value: totalEdges },
        ];

        const topRoles = roles.slice(0, 3).map((role) => ({
          label: role.role_name,
          value: `${role.counts.R + role.counts.A} R/A`,
        }));

        cards.push(...topRoles);

        const cardSelection = container
          .selectAll(".summary-card")
          .data(cards)
          .enter()
          .append("article")
          .attr("class", "summary-card");

        cardSelection.append("h3").text((d) => d.label);
        cardSelection.append("p").text((d) => d.value);
      }

      function renderWarnings(warnings) {
        const list = d3.select("#warnings-list");
        list.selectAll("*").remove();

        if (!warnings.length) {
          list.append("li").text("No current warnings.");
          return;
        }

        list
          .selectAll("li")
          .data(warnings)
          .enter()
          .append("li")
          .text((d) => `${d.action_name}: ${d.issue}`);
      }

      function renderLegend() {
        const legend = d3.select("#sankey-legend");
        legend.selectAll("*").remove();

        const items = Object.entries(STATUS_COLORS);
        const entry = legend
          .selectAll(".legend-item")
          .data(items)
          .enter()
          .append("div")
          .attr("class", "legend-item");

        entry
          .append("span")
          .attr("class", "legend-swatch")
          .style("background", ([, color]) => color);

        entry.append("span").text(([letter]) => letter);
      }

      function populateRoleFilter(roles) {
        const select = document.getElementById("role-filter");
        select.innerHTML = "";

        const defaultOption = document.createElement("option");
        defaultOption.value = "all";
        defaultOption.textContent = "All roles";
        select.appendChild(defaultOption);

        roles
          .slice()
          .sort((a, b) => a.name.localeCompare(b.name))
          .forEach((role) => {
            const option = document.createElement("option");
            option.value = role.id;
            option.textContent = role.name;
            select.appendChild(option);
          });

        select.value = filters.role;
        if (filters.role !== "all" && select.selectedIndex === -1) {
          filters.role = "all";
          select.value = filters.role;
        }

        if (!select.dataset.bound) {
          select.addEventListener("change", (event) => {
            filters.role = event.target.value || "all";
            if (cachedData) {
              redraw();
            }
          });
          select.dataset.bound = "true";
        }

        const raciSelect = document.getElementById("raci-filter");
        raciSelect.value = filters.raci;
        if (!raciSelect.dataset.bound) {
          raciSelect.addEventListener("change", (event) => {
            filters.raci = event.target.value || "all";
            if (cachedData) {
              redraw();
            }
          });
          raciSelect.dataset.bound = "true";
        }
      }

      function populateDependencyTypeFilter() {
        const select = document.getElementById("dependency-type-filter");
        select.innerHTML = "";

        const addOption = (value, label) => {
          const option = document.createElement("option");
          option.value = value;
          option.textContent = label;
          select.appendChild(option);
        };

        addOption("all", "All types");
        const types = dependencyTypes.length ? dependencyTypes : ["depends_on"];
        types.forEach((type) => addOption(type, type.replace(/_/g, " ")));

        if (filters.dependencyType !== "all" && !types.includes(filters.dependencyType)) {
          filters.dependencyType = "all";
        }
        select.value = filters.dependencyType;

        if (!select.dataset.bound) {
          select.addEventListener("change", (event) => {
            filters.dependencyType = event.target.value || "all";
            if (cachedData) {
              renderDependencyGraph(cachedData);
            }
          });
          select.dataset.bound = "true";
        }
      }

      function renderDependencyLegend() {
        const legend = d3.select("#dependency-legend");
        legend.selectAll("*").remove();

        const types = dependencyTypes.length ? dependencyTypes : ["depends_on"];
        const entry = legend.selectAll("span").data(types).enter().append("span");

        entry
          .append("span")
          .style("display", "inline-block")
          .style("width", "14px")
          .style("height", "14px")
          .style("border-radius", "3px")
          .style("background", (d) => dependencyColorScale(d))
          .style("margin-right", "0.35rem");

        entry.append("span").text((d) => d.replace(/_/g, " "));
      }

      function renderSankey(data) {
        const container = d3.select("#sankey-placeholder");
        container.selectAll("*").remove();

        if (!data.relationships.length || !data.actions.length) {
          container.append("p").text("No relationships to display.");
          return;
        }

        const groupOrder = new Map(data.activity_groups.map((group, index) => [group.id, index]));

        const links = aggregateLinks(data);
        const filteredLinks = links.filter((link) => {
          const roleMatch = filters.role === "all" || link.role_id === filters.role;
          const raciMatch = filters.raci === "all" || link.raci === filters.raci;
          return roleMatch && raciMatch;
        });

        if (!filteredLinks.length) {
          container.append("p").text("No relationships match the current filters.");
          return;
        }

        const activeActionIds = new Set(filteredLinks.map((link) => link.action_id));
        const activeRoleIds = new Set(filteredLinks.map((link) => link.role_id));

        const actions = data.actions
          .filter((action) => activeActionIds.has(action.id))
          .sort((a, b) => {
            const groupComparison = groupOrder.get(a.group_id) - groupOrder.get(b.group_id);
            if (groupComparison !== 0) return groupComparison;
            return a.name.localeCompare(b.name);
          });

        const roles = data.roles
          .filter((role) => activeRoleIds.has(role.id))
          .sort((a, b) => a.name.localeCompare(b.name));

        const actionLookup = new Map(actions.map((action) => [action.id, action]));
        const groupLookup = new Map(data.activity_groups.map((group) => [group.id, group.title]));
        const roleLookup = new Map(roles.map((role) => [role.id, role.name]));

        const nodes = [
          ...actions.map((action) => ({
            id: `action:${action.id}`,
            name: action.name,
            type: "action",
            group_id: action.group_id,
          })),
          ...roles.map((role) => ({
            id: `role:${role.id}`,
            name: role.name,
            type: "role",
          })),
        ];

        const linksForGraph = filteredLinks.map((link) => ({
          ...link,
          source: `action:${link.action_id}`,
          target: `role:${link.role_id}`,
        }));

        const targetHeight = Math.max(440, actions.length * 24);
        container.style("min-height", `${targetHeight + 32}px`);
        container.style("height", `${targetHeight + 32}px`);

        const bbox = container.node().getBoundingClientRect();
        const width = Math.max(640, bbox.width || container.node().clientWidth || 640);
        const height = targetHeight;
        const margin = { top: 28, right: 60, bottom: 24, left: 220 };

        const svg = container.append("svg").attr("width", width).attr("height", height);

        const sankeyGenerator = d3
          .sankey()
          .nodeId((d) => d.id)
          .nodeAlign(d3.sankeyLeft)
          .nodeWidth(16)
          .nodePadding(20)
          .nodeSort((a, b) => {
            if (a.type !== b.type) {
              return a.type === "action" ? -1 : 1;
            }
            if (a.type === "action" && b.type === "action") {
              const groupComparison = groupOrder.get(a.group_id) - groupOrder.get(b.group_id);
              if (groupComparison !== 0) return groupComparison;
              return a.name.localeCompare(b.name);
            }
            if (a.type === "role" && b.type === "role") {
              return a.name.localeCompare(b.name);
            }
            return 0;
          })
          .extent([
            [margin.left, margin.top],
            [width - margin.right, height - margin.bottom],
          ]);

        const graph = sankeyGenerator({
          nodes: nodes.map((node) => ({ ...node })),
          links: linksForGraph.map((link) => ({ ...link })),
        });

        const actionNodes = graph.nodes.filter((node) => node.type === "action");
        if (!actionNodes.length) {
          container.append("p").text("No action nodes available.");
          return;
        }

        const actionColumnX0 = d3.min(actionNodes, (node) => node.x0);
        const actionColumnX1 = d3.max(actionNodes, (node) => node.x1);
        const bandPaddingX = 16;
        const bandBaseX = margin.left;
        const bandWidth = Math.min(
          Math.max(220, actionColumnX1 - actionColumnX0 + bandPaddingX * 2),
          width - margin.right - bandBaseX - 8
        );

        const groupColor = d3.scaleOrdinal(data.activity_groups.map((group) => group.id), d3.schemeTableau10);

        const groupBands = data.activity_groups
          .map((group) => {
            const groupNodes = actionNodes.filter((node) => node.group_id === group.id);
            if (!groupNodes.length) return null;
            return {
              id: group.id,
              title: group.title,
              y0: d3.min(groupNodes, (node) => node.y0),
              y1: d3.max(groupNodes, (node) => node.y1),
            };
          })
          .filter(Boolean);

        const bandGroup = svg.append("g").attr("class", "group-bands");

        const bandG = bandGroup
          .selectAll("g")
          .data(groupBands)
          .enter()
          .append("g")
          .attr("transform", (d) => `translate(${bandBaseX}, ${Math.max(margin.top - 14, d.y0 - 16)})`);

        bandG
          .append("rect")
          .attr("x", 0)
          .attr("y", 0)
          .attr("width", bandWidth)
          .attr("height", (d) => Math.max(34, d.y1 - d.y0 + 28))
          .attr("fill", (d) => {
            const base = d3.color(groupColor(d.id));
            base.opacity = 0.08;
            return base;
          })
          .attr("stroke", (d) => groupColor(d.id))
          .attr("stroke-dasharray", "6 6")
          .attr("stroke-opacity", 0.35);

        bandG
          .append("text")
          .attr("x", -12)
          .attr("y", (d) => (Math.max(34, d.y1 - d.y0 + 28) / 2))
          .attr("dy", "0.35em")
          .attr("text-anchor", "end")
          .attr("font-weight", 700)
          .attr("fill", "#1f2937")
          .text((d) => d.title);

        const linkGroup = svg.append("g").attr("fill", "none").attr("stroke-opacity", 0.55);

        const link = linkGroup
          .selectAll("path")
          .data(graph.links)
          .enter()
          .append("path")
          .attr("d", d3.sankeyLinkHorizontal())
          .attr("stroke", (d) => STATUS_COLORS[d.raci] || "#94a3b8")
          .attr("stroke-width", (d) => Math.max(1, d.width))
          .attr("opacity", 0.85);

        link.append("title").text((d) => {
          const action = actionLookup.get(d.action_id);
          const actionName = action ? action.name : "Unknown action";
          const groupTitle = action ? groupLookup.get(action.group_id) : "Unknown group";
          const roleName = roleLookup.get(d.role_id) || "Unknown role";
          const countLabel = `• ${d.value} assignment${d.value === 1 ? "" : "s"}`;
          return `${groupTitle} → ${actionName} → ${roleName} (${d.raci}) ${countLabel}`;
        });

        const node = svg.append("g").selectAll(".node").data(graph.nodes).enter().append("g").attr("class", "node");

        node
          .append("rect")
          .attr("x", (d) => d.x0)
          .attr("y", (d) => d.y0)
          .attr("height", (d) => Math.max(2, d.y1 - d.y0))
          .attr("width", (d) => Math.max(1, d.x1 - d.x0))
          .attr("rx", 2)
          .attr("ry", 2)
          .attr("fill", (d) => NODE_COLORS[d.type] || "#64748b")
          .attr("fill-opacity", 0.9);

        node
          .append("text")
          .attr("x", (d) => (d.x0 < width / 2 ? d.x1 + 8 : d.x0 - 8))
          .attr("y", (d) => Math.max(12, (d.y0 + d.y1) / 2))
          .attr("dy", "0.35em")
          .attr("text-anchor", (d) => (d.x0 < width / 2 ? "start" : "end"))
          .text((d) => `${d.name} (${Math.round(d.value)})`);
      }

      function aggregateLinks(data) {
        const actionLookup = new Map(data.actions.map((action) => [action.id, action]));
        const linkMap = new Map();

        for (const rel of data.relationships) {
          const action = actionLookup.get(rel.action_id);
          if (!action) continue;
          const key = `${rel.action_id}|${rel.role_id}|${rel.raci}`;
          if (!linkMap.has(key)) {
            linkMap.set(key, {
              action_id: rel.action_id,
              role_id: rel.role_id,
              group_id: action.group_id,
              raci: rel.raci,
              value: 0,
            });
          }
          linkMap.get(key).value += 1;
        }
        return Array.from(linkMap.values());
      }

      function actionMatchesFilters(actionId) {
        const roleFilter = filters.role;
        const raciFilter = filters.raci;
        if (roleFilter === "all" && raciFilter === "all") {
          return true;
        }

        const assignments = actionAssignments.get(actionId);
        if (!assignments) return false;

        if (roleFilter !== "all") {
          const letters = assignments.get(roleFilter);
          if (!letters) return false;
          if (raciFilter === "all") return true;
          return letters.has(raciFilter);
        }

        if (raciFilter === "all") {
          return true;
        }

        for (const letters of assignments.values()) {
          if (letters.has(raciFilter)) return true;
        }
        return false;
      }

      function renderDependencyGraph(data) {
        const container = d3.select("#dependency-graph");
        container.selectAll("*").remove();

        const allEdges = data.activity_dependencies || [];
        const typeFilteredEdges =
          filters.dependencyType === "all"
            ? allEdges
            : allEdges.filter((edge) => edge.type === filters.dependencyType);

        const roleLookup = new Map(data.roles.map((role) => [role.id, role.name]));
        const matchedActions = new Set();
        for (const action of data.actions) {
          if (actionMatchesFilters(action.id)) {
            matchedActions.add(action.id);
          }
        }

        const filterActive = filters.role !== "all" || filters.raci !== "all";
        const dependencyEdges = typeFilteredEdges.filter((edge) => {
          if (!filterActive) return true;
          return matchedActions.has(edge.source_action_id) || matchedActions.has(edge.target_action_id);
        });

        const visibleActionIds = new Set(matchedActions);
        dependencyEdges.forEach((edge) => {
          visibleActionIds.add(edge.source_action_id);
          visibleActionIds.add(edge.target_action_id);
        });

        if (visibleActionIds.size === 0) {
          container.append("p").text("No activities match the current filters.");
          return;
        }

        const actionOrder = new Map(data.actions.map((action, index) => [action.id, index]));
        const nodesByGroup = data.activity_groups.map((group) => {
          const actions = data.actions
            .filter((action) => action.group_id === group.id && visibleActionIds.has(action.id))
            .sort((a, b) => actionOrder.get(a.id) - actionOrder.get(b.id));
          return { group, actions };
        });

        const maxNodes = Math.max(1, ...nodesByGroup.map((col) => col.actions.length));
        const margin = { top: 80, right: 200, bottom: 40, left: 260 };
        const nodeWidth = 260;
        const nodeHeight = 42;
        const nodeGap = 30;

        const containerNode = container.node();
        const bbox = containerNode.getBoundingClientRect();
        const columnCount = data.activity_groups.length;
        const baseSpacing = columnCount > 1 ? nodeWidth + 220 : 0;
        const width = margin.left + margin.right + baseSpacing * Math.max(0, columnCount - 1);
        const height = Math.max(
          margin.top + margin.bottom + nodeHeight,
          margin.top + margin.bottom + (maxNodes - 1) * (nodeHeight + nodeGap) + nodeHeight
        );

        container.style("min-height", `${height}px`);
        container.style("height", `${height}px`);

        const availableWidth = bbox.width || containerNode.clientWidth || 0;
        if (availableWidth < width) {
          container.style("overflow-x", "auto");
        } else {
          container.style("overflow-x", "hidden");
        }

        const effectiveWidth = Math.max(width, availableWidth, 1100);
        const svg = container.append("svg").attr("width", effectiveWidth).attr("height", height);
        const effectiveSpacing =
          columnCount > 1
            ? Math.max(
                baseSpacing,
                (effectiveWidth - margin.left - margin.right) / Math.max(1, columnCount - 1)
              )
            : 0;
        const groupColor = d3.scaleOrdinal(data.activity_groups.map((group) => group.id), d3.schemePastel1);

        const nodePositions = new Map();
        const nodesData = [];
        const groupHighlight = new Map();
        const groupBandsData = [];
        const bandPaddingX = 28;
        const bandPaddingY = 16;
        const halfWidth = nodeWidth / 2;
        const halfHeight = nodeHeight / 2;

        const anchorPoint = (center, other) => {
          const dx = other.x - center.x;
          const dy = other.y - center.y;
          if (dx === 0 && dy === 0) {
            return { x: center.x, y: center.y };
          }
          const scaleX = dx !== 0 ? halfWidth / Math.abs(dx) : Infinity;
          const scaleY = dy !== 0 ? halfHeight / Math.abs(dy) : Infinity;
          let scale = Math.min(scaleX, scaleY);
          if (!isFinite(scale)) {
            scale = scaleX === Infinity ? scaleY : scaleX;
          }
          if (!isFinite(scale) || scale === 0) {
            return { x: center.x, y: center.y };
          }
          return {
            x: center.x + dx * scale,
            y: center.y + dy * scale,
          };
        };

        nodesByGroup.forEach((col, colIndex) => {
          const baseX = margin.left + colIndex * effectiveSpacing;
          let highlightCount = 0;
          let minY = Infinity;
          let maxY = -Infinity;

          col.actions.forEach((action, actionIndex) => {
            const x = baseX;
            const y = margin.top + actionIndex * (nodeHeight + nodeGap);
            nodePositions.set(action.id, { x, y });
            const highlight = filterActive ? matchedActions.has(action.id) : true;
            if (highlight) highlightCount += 1;
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
            nodesData.push({
              action,
              group: col.group,
              x,
              y,
              highlight,
            });
          });

          const hasNodes = col.actions.length > 0;
          const groupIsHighlighted = hasNodes ? (filterActive ? highlightCount > 0 : true) : false;
          groupHighlight.set(col.group.id, groupIsHighlighted);

          if (hasNodes) {
            const top = (minY === Infinity ? margin.top : minY) - nodeHeight / 2 - bandPaddingY;
            const bottom = (maxY === -Infinity ? minY : maxY) + nodeHeight / 2 + bandPaddingY;
            groupBandsData.push({
              group: col.group,
              x: baseX - nodeWidth / 2 - bandPaddingX,
              width: nodeWidth + bandPaddingX * 2,
              y: top,
              height: Math.max(60, bottom - top),
              highlight: groupIsHighlighted,
            });
          }
        });

        const edgesData = dependencyEdges
          .map((edge) => {
            const targetPos = nodePositions.get(edge.target_action_id);
            const sourcePos = nodePositions.get(edge.source_action_id);
            if (!targetPos || !sourcePos) return null;
            const highlight = filterActive
              ? matchedActions.has(edge.source_action_id) || matchedActions.has(edge.target_action_id)
              : true;
            return {
              ...edge,
              startCenter: targetPos,
              endCenter: sourcePos,
              start: anchorPoint(targetPos, sourcePos),
              end: anchorPoint(sourcePos, targetPos),
              highlight,
            };
          })
          .filter(Boolean);

        const markerTypes = Array.from(new Set(edgesData.map((edge) => edge.type)));
        const defs = svg.append("defs");
        markerTypes.forEach((type) => {
          const color = dependencyColorScale(type);
          defs
            .append("marker")
            .attr("id", `arrow-${type}`)
            .attr("viewBox", "0 -4 8 8")
            .attr("refX", 8)
            .attr("refY", 0)
            .attr("markerWidth", 8)
            .attr("markerHeight", 8)
            .attr("orient", "auto")
            .attr("markerUnits", "strokeWidth")
            .append("path")
            .attr("d", "M0,-4L8,0L0,4")
            .attr("fill", color);
        });

        const bandGroup = svg.append("g").attr("class", "dependency-bands");
        bandGroup
          .selectAll("rect")
          .data(groupBandsData)
          .enter()
          .append("rect")
          .attr("x", (d) => d.x)
          .attr("y", (d) => d.y)
          .attr("width", (d) => d.width)
          .attr("height", (d) => d.height)
          .attr("rx", 18)
          .attr("ry", 18)
          .attr("fill", (d) => {
            const base = d3.color(groupColor(d.group.id));
            if (base) {
              base.opacity = d.highlight ? 0.22 : 0.08;
              return base;
            }
            return d.highlight ? "rgba(37,99,235,0.18)" : "rgba(148,163,184,0.08)";
          })
          .attr("stroke", (d) => {
            const base = d3.color(groupColor(d.group.id));
            if (base) {
              base.opacity = d.highlight ? 0.55 : 0.25;
              return base;
            }
            return d.highlight ? "rgba(37,99,235,0.45)" : "rgba(148,163,184,0.25)";
          })
          .attr("stroke-dasharray", (d) => (d.highlight ? null : "8 6"));

        svg
          .append("g")
          .attr("class", "dependency-headers")
          .selectAll("text")
          .data(data.activity_groups)
          .enter()
          .append("text")
          .attr("x", (d, index) => margin.left + index * effectiveSpacing)
          .attr("y", margin.top - 42)
          .attr("text-anchor", "middle")
          .attr("font-weight", 700)
          .attr("fill", "#1f2937")
          .attr("opacity", (d) => (groupHighlight.get(d.id) ? 1 : 0.45))
          .classed("highlight", (d) => groupHighlight.get(d.id))
          .text((d) => d.title);

        if (!edgesData.length) {
          svg
            .append("text")
            .attr("x", margin.left)
            .attr("y", margin.top - 15)
            .attr("fill", "#64748b")
            .attr("font-size", 12)
            .text("No dependency edges match the current filters. Showing standalone activities.");
        }

        const edgeGroup = svg.append("g").attr("class", "dependency-edges");
        const curvedLink = (start, end) => {
          const midX = (start.x + end.x) / 2;
          return `M${start.x},${start.y} C${midX},${start.y} ${midX},${end.y} ${end.x},${end.y}`;
        };

        const edgeSelection = edgeGroup
          .selectAll("path")
          .data(edgesData)
          .enter()
          .append("path")
          .attr("class", "dependency-edge")
          .attr("d", (d) => curvedLink(d.start, d.end))
          .attr("stroke", (d) => dependencyColorScale(d.type))
          .attr("stroke-width", 2)
          .attr("marker-end", (d) => `url(#arrow-${d.type})`)
          .classed("dimmed", (d) => filterActive && !d.highlight);

        edgeSelection
          .append("title")
          .text((d) => `${d.source_action_name} depends on ${d.target_action_name} (${d.type.replace(/_/g, " ")})`);

        const nodesGroup = svg.append("g").attr("class", "dependency-nodes");
        const nodeSelection = nodesGroup
          .selectAll(".activity-node")
          .data(nodesData)
          .enter()
          .append("g")
          .attr("class", "activity-node")
          .classed("highlight", (d) => d.highlight)
          .classed("dimmed", (d) => filterActive && !d.highlight)
          .attr("transform", (d) => `translate(${d.x - nodeWidth / 2}, ${d.y - nodeHeight / 2})`);

        nodeSelection
          .append("rect")
          .attr("width", nodeWidth)
          .attr("height", nodeHeight)
          .attr("rx", 6)
          .attr("ry", 6)
          .attr("fill", (d) => {
            const base = d3.color(groupColor(d.group.id));
            const fill = base ? base.copy() : d3.color("#e2e8f0");
            fill.opacity = d.highlight ? 0.95 : 0.5;
            return fill;
          });

        const labels = nodeSelection
          .append("text")
          .attr("x", 14)
          .attr("y", 14)
          .attr("fill", "#1f2937")
          .attr("font-size", 11)
          .attr("opacity", (d) => (d.highlight ? 1 : 0.55))
          .attr("dominant-baseline", "hanging")
          .text((d) => d.action.name);

        wrapText(labels, nodeWidth - 28, nodeHeight);

        nodeSelection
          .append("title")
          .text((d) => {
            const lines = [`${d.action.name}`, `Group: ${d.group.title}`];
            const assignments = actionAssignments.get(d.action.id);
            if (assignments) {
              const roleLines = [];
              assignments.forEach((letters, roleId) => {
                const roleName = roleLookup.get(roleId) || roleId;
                roleLines.push(`${roleName}: ${Array.from(letters).sort().join("/")}`);
              });
              roleLines.sort();
              lines.push(...roleLines);
            }
            return lines.join("\n");
          });
      }

      function renderResponsibilityMatrix(data) {
        closeMatrixEditor();

        const table = d3.select("#responsibility-matrix");
        table.selectAll("*").remove();

        const roles = [...data.roles].sort((a, b) => a.name.localeCompare(b.name));
        const roleLookup = new Map(roles.map((role) => [role.id, role.name]));

        const thead = table.append("thead");
        const headerRow = thead.append("tr");
        headerRow.append("th").text("Lifecycle / Activity");
        roles.forEach((role) => {
          headerRow
            .append("th")
            .attr("class", "role-header" + (filters.role === role.id ? " highlight" : ""))
            .text(role.name);
        });

        const tbody = table.append("tbody");
        const raciFilterActive = filters.raci !== "all";
        const roleFilterActive = filters.role !== "all";

        data.activity_groups.forEach((group) => {
          const groupActions = data.actions
            .filter((action) => action.group_id === group.id)
            .sort((a, b) => a.name.localeCompare(b.name));
          if (!groupActions.length) {
            return;
          }

          const groupRow = tbody.append("tr").attr("class", "matrix-group-row");
          groupRow.append("th").attr("colspan", roles.length + 1).text(group.title);

          groupActions.forEach((action) => {
            const row = tbody.append("tr").attr("class", "matrix-row");
            const actionHighlight = actionMatchesFilters(action.id);
            if (actionHighlight) {
              row.classed("highlight", true);
            } else if (roleFilterActive || raciFilterActive) {
              row.classed("dimmed", true);
            }

          row
            .append("td")
            .attr("class", "matrix-action-cell")
            .text(action.name);

          const assignments = actionAssignments.get(action.id) || new Map();

          roles.forEach((role) => {
            const lettersSet = assignments.get(role.id) || new Set();
            const letters = Array.from(lettersSet).sort();
            const cellData = {
              actionId: action.id,
              actionName: action.name,
              roleId: role.id,
              roleName: role.name,
              letters,
            };
            const cell = row
              .append("td")
              .attr("class", "matrix-cell")
              .attr("tabindex", 0)
              .datum(cellData)
              .on("click", handleMatrixCellClick)
              .on("keydown", handleMatrixCellKeydown);
            const matchesRole = !roleFilterActive || role.id === filters.role;
            const matchesRaci = !raciFilterActive || letters.includes(filters.raci);
            const hasLetters = letters.length > 0;

            if (!hasLetters) {
                cell.classed("empty", true).text("-");
              } else {
                cell.text(letters.join("/"));
              }

              if (hasLetters && actionHighlight && matchesRole && matchesRaci) {
                cell.classed("highlight", true);
              } else if (roleFilterActive || raciFilterActive) {
                cell.classed("dimmed", true);
              }

              cell.append("title").text(() => {
                if (!hasLetters) {
                  return `${role.name} has no assignment`; 
                }
                return `${action.name}\nRole: ${role.name}\nResponsibility: ${letters.join("/")}`;
              });
            });
          });
        });
      }

      function setupDatasetControls() {
        datasetStatusEl = document.getElementById("dataset-status");
        const uploadInput = document.getElementById("dataset-upload");
        const resetButton = document.getElementById("dataset-reset");
        const filenameInput = document.getElementById("dataset-filename");
        const downloadMatrixButton = document.getElementById("download-matrix");
        const downloadJsonButton = document.getElementById("download-json");

        if (uploadInput) {
          uploadInput.addEventListener("change", (event) => {
            const file = event.target.files && event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (evt) => {
              try {
                const parsed = JSON.parse(evt.target.result);
                applyData(parsed, {
                  resetFilters: true,
                  statusMessage: `Loaded dataset from ${file.name}`,
                });
              } catch (error) {
                console.error("Failed to load dataset", error);
                if (datasetStatusEl) {
                  datasetStatusEl.textContent = `Failed to load ${file.name}: ${error.message}`;
                }
              }
            };
            reader.readAsText(file);
            uploadInput.value = "";
          });
        }

        if (resetButton) {
          resetButton.addEventListener("click", () => {
            if (originalData) {
              applyData(originalData, {
                resetFilters: true,
                statusMessage: "Reverted to default dataset.",
              });
            }
          });
        }

        if (downloadMatrixButton) {
          downloadMatrixButton.addEventListener("click", () => {
            if (!cachedData) return;
            const baseInput = filenameInput ? filenameInput.value : "";
            const base = (baseInput || "raci_matrix").trim() || "raci_matrix";
            const filename = base.toLowerCase().endsWith(".csv") ? base : `${base}.csv`;
            const csv = buildMatrixCsv(cachedData);
            downloadFile(csv, filename, "text/csv");
            if (datasetStatusEl) {
              datasetStatusEl.textContent = `Downloaded ${filename}`;
            }
          });
        }

        if (downloadJsonButton) {
          downloadJsonButton.addEventListener("click", () => {
            if (!cachedData) return;
            const baseInput = filenameInput ? filenameInput.value : "";
            const base = (baseInput || "raci_matrix").trim() || "raci_matrix";
            const filename = base.toLowerCase().endsWith(".json") ? base : `${base}.json`;
            const json = JSON.stringify(cachedData, null, 2);
            downloadFile(json, filename, "application/json");
            if (datasetStatusEl) {
              datasetStatusEl.textContent = `Downloaded ${filename}`;
            }
          });
        }
      }

      function applyData(data, { resetFilters = false, statusMessage = null } = {}) {
        const normalized = normalizeData(data || {});
        cachedData = normalized;
        actionAssignments = buildActionAssignments(normalized.relationships);
        dependencyTypes = Array.from(new Set((normalized.activity_dependencies || []).map((d) => d.type))).sort();
        dependencyColorScale = d3
          .scaleOrdinal(dependencyTypes.length ? dependencyTypes : ["depends_on"], d3.schemeTableau10);

        if (resetFilters) {
          filters.role = "all";
          filters.raci = "all";
          filters.dependencyType = "all";
        }

        if (filters.role !== "all" && !normalized.roles.some((role) => role.id === filters.role)) {
          filters.role = "all";
        }
        if (filters.dependencyType !== "all" && !dependencyTypes.includes(filters.dependencyType)) {
          filters.dependencyType = "all";
        }

        renderSummary(normalized);
        renderWarnings(normalized.metrics.action_warnings || []);
        populateRoleFilter(normalized.roles);
        populateDependencyTypeFilter();
        renderLegend();
        renderDependencyLegend();
        closeMatrixEditor();
        redraw();

        const statusBanner = document.getElementById("status-banner");
        if (statusBanner) {
          statusBanner.textContent = `Loaded ${normalized.activity_groups.length} lifecycle groups • ${
            normalized.actions.length
          } actions`;
        }

        if (datasetStatusEl) {
          if (statusMessage) {
            datasetStatusEl.textContent = statusMessage;
          } else {
            datasetStatusEl.textContent = `Loaded dataset with ${normalized.activity_groups.length} groups and ${normalized.actions.length} actions.`;
          }
        }
      }

      function redraw() {
        if (!cachedData) return;
        renderSankey(cachedData);
        renderDependencyGraph(cachedData);
        renderResponsibilityMatrix(cachedData);
      }

      function buildMatrixCsv(data) {
        const header = [
          "group_id",
          "group_title",
          "action_id",
          "action_name",
          "role_id",
          "role_name",
          "raci",
        ];
        const groupLookup = new Map((data.activity_groups || []).map((group) => [group.id, group.title]));
        const actionLookup = new Map((data.actions || []).map((action) => [action.id, action.name]));
        const roleLookup = new Map((data.roles || []).map((role) => [role.id, role.name]));
        const lines = [header.join(",")];
        (data.relationships || []).forEach((rel) => {
          const row = [
            rel.group_id || "",
            groupLookup.get(rel.group_id) || "",
            rel.action_id || "",
            actionLookup.get(rel.action_id) || "",
            rel.role_id || "",
            roleLookup.get(rel.role_id) || "",
            rel.raci || "",
          ].map((value) => {
            const str = String(value ?? "");
            return /[",\n]/.test(str) ? `"${str.replace(/"/g, '""')}"` : str;
          });
          lines.push(row.join(","));
        });
        return lines.join("\n");
      }

      function downloadFile(content, filename, mimeType) {
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }

      function handleMatrixCellClick(event, cellData) {
        event.stopPropagation();
        openMatrixEditor(event.currentTarget, cellData);
      }

      function handleMatrixCellKeydown(event, cellData) {
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          openMatrixEditor(event.currentTarget, cellData);
        }
      }

      function ensureMatrixEditor() {
        if (matrixEditor) return matrixEditor;
        matrixEditor = document.createElement("div");
        matrixEditor.className = "matrix-editor";
        matrixEditor.innerHTML = `
          <div class="matrix-editor-options">
            ${EDIT_LETTERS.map((letter) => `<label><input type="checkbox" value="${letter}"> ${letter}</label>`).join("")}
          </div>
          <div class="matrix-editor-actions">
            <button type="button" class="secondary" data-action="cancel">Cancel</button>
            <button type="button" data-action="save">Save</button>
          </div>
        `;
        document.body.appendChild(matrixEditor);

        matrixEditor.addEventListener("click", (event) => event.stopPropagation());

        const saveButton = matrixEditor.querySelector('button[data-action="save"]');
        const cancelButton = matrixEditor.querySelector('button[data-action="cancel"]');

        if (saveButton) {
          saveButton.addEventListener("click", () => {
            if (!matrixEditorState) return;
            const checkboxes = Array.from(matrixEditor.querySelectorAll('input[type="checkbox"]'));
            const selectedLetters = checkboxes.filter((input) => input.checked).map((input) => input.value);
            applyMatrixEdit(matrixEditorState.actionId, matrixEditorState.roleId, selectedLetters, matrixEditorState);
            closeMatrixEditor();
          });
        }

        if (cancelButton) {
          cancelButton.addEventListener("click", () => {
            closeMatrixEditor();
          });
        }

        document.addEventListener("click", handleMatrixEditorDocumentClick);
        document.addEventListener("keydown", handleMatrixEditorKeydown);

        return matrixEditor;
      }

      function openMatrixEditor(target, cellData) {
        if (!cachedData) return;
        const editor = ensureMatrixEditor();
        const previouslyEditing = matrixEditorState && matrixEditorState.anchor;
        if (previouslyEditing && previouslyEditing !== target) {
          previouslyEditing.classList.remove("editing");
        }

        matrixEditorState = {
          actionId: cellData.actionId,
          roleId: cellData.roleId,
          actionName: cellData.actionName,
          roleName: cellData.roleName,
          anchor: target,
        };

        const checkboxes = Array.from(editor.querySelectorAll('input[type="checkbox"]'));
        const currentLetters = (cellData.letters || []).map((letter) => letter.toUpperCase());
        checkboxes.forEach((input) => {
          input.checked = currentLetters.indexOf(input.value) >= 0;
        });

        target.classList.add("editing");

        editor.style.display = "block";
        editor.style.visibility = "hidden";
        editor.style.left = "0px";
        editor.style.top = "0px";

        const rect = target.getBoundingClientRect();
        const editorRect = editor.getBoundingClientRect();
        const viewportWidth = document.documentElement.clientWidth;
        const viewportHeight = document.documentElement.clientHeight || window.innerHeight;
        const scrollX = window.pageXOffset || document.documentElement.scrollLeft || 0;
        const scrollY = window.pageYOffset || document.documentElement.scrollTop || 0;

        let left = rect.left + scrollX;
        let top = rect.bottom + scrollY + 6;

        if (left + editorRect.width > scrollX + viewportWidth - 8) {
          left = scrollX + viewportWidth - editorRect.width - 8;
        }
        if (top + editorRect.height > scrollY + viewportHeight - 8) {
          top = rect.top + scrollY - editorRect.height - 6;
        }

        left = Math.max(scrollX + 8, left);
        top = Math.max(scrollY + 8, top);

        editor.style.left = `${left}px`;
        editor.style.top = `${top}px`;
        editor.style.visibility = "visible";
      }

      function closeMatrixEditor() {
        if (!matrixEditor) return;
        matrixEditor.style.display = "none";
        if (matrixEditorState && matrixEditorState.anchor) {
          matrixEditorState.anchor.classList.remove("editing");
        }
        matrixEditorState = null;
      }

      function handleMatrixEditorDocumentClick(event) {
        if (!matrixEditor || matrixEditor.style.display !== "block") return;
        if (!matrixEditor.contains(event.target)) {
          closeMatrixEditor();
        }
      }

      function handleMatrixEditorKeydown(event) {
        if ((event.key === "Escape" || event.key === "Esc") && matrixEditor && matrixEditor.style.display === "block") {
          event.stopPropagation();
          closeMatrixEditor();
        }
      }

      function rebuildRelationshipsFromAssignments() {
        if (!cachedData) return;
        const actionInfo = new Map((cachedData.actions || []).map((action) => [action.id, action]));
        const relationships = [];

        actionAssignments.forEach((roleMap, actionId) => {
          const action = actionInfo.get(actionId);
          if (!action) return;
          roleMap.forEach((letterSet, roleId) => {
            const letters = Array.from(letterSet).sort();
            letters.forEach((letter) => {
              relationships.push({
                action_id: actionId,
                role_id: roleId,
                raci: letter,
                group_id: action.group_id,
              });
            });
          });
        });

        relationships.sort((a, b) => {
          if (a.group_id !== b.group_id) return (a.group_id || "").localeCompare(b.group_id || "");
          if (a.action_id !== b.action_id) return (a.action_id || "").localeCompare(b.action_id || "");
          if (a.role_id !== b.role_id) return (a.role_id || "").localeCompare(b.role_id || "");
          return a.raci.localeCompare(b.raci);
        });

        cachedData.relationships = relationships;
      }

      function recalculateMetrics(data) {
        if (!data) return;

        const roleCounts = new Map();
        const groupCounts = new Map();
        const actionWarnings = [];
        const roleNameLookup = new Map((data.roles || []).map((role) => [role.id, role.name]));
        const actions = data.actions || [];
        const groups = data.activity_groups || [];

        const createEmptyCounts = () => ({ R: 0, A: 0, C: 0, I: 0 });

        actions.forEach((action) => {
          const roleMap = actionAssignments.get(action.id) || new Map();
          const responsibleRoles = [];
          const accountableRoles = [];

          roleMap.forEach((letterSet, roleId) => {
            const letters = Array.from(letterSet);
            let counts = roleCounts.get(roleId);
            if (!counts) {
              counts = createEmptyCounts();
              roleCounts.set(roleId, counts);
            }
            letters.forEach((letter) => {
              if (!counts[letter]) counts[letter] = 0;
              counts[letter] += 1;

              let groupCountsEntry = groupCounts.get(action.group_id);
              if (!groupCountsEntry) {
                groupCountsEntry = createEmptyCounts();
                groupCounts.set(action.group_id, groupCountsEntry);
              }
              groupCountsEntry[letter] += 1;

              if (letter === "R") {
                responsibleRoles.push(roleId);
              } else if (letter === "A") {
                accountableRoles.push(roleId);
              }
            });
          });

          if (responsibleRoles.length === 0) {
            actionWarnings.push({
              action_id: action.id,
              action_name: action.name,
              issue: "Missing Responsible assignment",
            });
          } else if (responsibleRoles.length > 1) {
            const names = responsibleRoles.map((roleId) => roleNameLookup.get(roleId) || roleId);
            actionWarnings.push({
              action_id: action.id,
              action_name: action.name,
              issue: `Multiple Responsible assignments: ${names.join(", ")}`,
            });
          }

          if (accountableRoles.length === 0) {
            actionWarnings.push({
              action_id: action.id,
              action_name: action.name,
              issue: "Missing Accountable assignment",
            });
          } else if (accountableRoles.length > 1) {
            const names = accountableRoles.map((roleId) => roleNameLookup.get(roleId) || roleId);
            actionWarnings.push({
              action_id: action.id,
              action_name: action.name,
              issue: `Multiple Accountable assignments: ${names.join(", ")}`,
            });
          }
        });

        const roleSummary = (data.roles || []).map((role) => {
          const counts = roleCounts.get(role.id) || createEmptyCounts();
          const countsCopy = {
            R: counts.R || 0,
            A: counts.A || 0,
            C: counts.C || 0,
            I: counts.I || 0,
          };
          const totalAssignments = countsCopy.R + countsCopy.A + countsCopy.C + countsCopy.I;
          return {
            role_id: role.id,
            role_name: role.name,
            aliases: role.aliases || [],
            counts: countsCopy,
            total_assignments: totalAssignments,
          };
        });

        roleSummary.sort((a, b) => b.total_assignments - a.total_assignments || a.role_name.localeCompare(b.role_name));

        const overloadedRoles = roleSummary
          .slice()
          .sort((a, b) => {
            const aCore = (a.counts.R || 0) + (a.counts.A || 0);
            const bCore = (b.counts.R || 0) + (b.counts.A || 0);
            if (bCore !== aCore) return bCore - aCore;
            return b.total_assignments - a.total_assignments;
          })
          .slice(0, 3);

        const groupSummary = {};
        groups.forEach((group) => {
          const counts = groupCounts.get(group.id) || createEmptyCounts();
          groupSummary[group.id] = {
            title: group.title,
            action_count: actions.filter((action) => action.group_id === group.id).length,
            edge_distribution: {
              R: counts.R || 0,
              A: counts.A || 0,
              C: counts.C || 0,
              I: counts.I || 0,
            },
          };
        });

        data.metrics = {
          ...(data.metrics || {}),
          role_summary: roleSummary,
          overloaded_roles: overloadedRoles,
          action_warnings: actionWarnings,
          group_summary: groupSummary,
        };
      }

      function applyMatrixEdit(actionId, roleId, letters, meta) {
        if (!cachedData) return;
        const normalizedLetters = Array.from(
          new Set(
            (letters || [])
              .map((letter) => (letter || "").toString().trim().toUpperCase())
              .filter((letter) => EDIT_LETTERS.indexOf(letter) >= 0)
          )
        ).sort();

        let roleMap = actionAssignments.get(actionId);
        if (!roleMap) {
          roleMap = new Map();
          actionAssignments.set(actionId, roleMap);
        }

        if (normalizedLetters.length) {
          roleMap.set(roleId, new Set(normalizedLetters));
        } else {
          roleMap.delete(roleId);
          if (roleMap.size === 0) {
            actionAssignments.delete(actionId);
          }
        }

        rebuildRelationshipsFromAssignments();
        recalculateMetrics(cachedData);
        redraw();

        if (datasetStatusEl) {
          const displayLetters = normalizedLetters.length ? normalizedLetters.join("/") : "none";
          const actionName = meta && meta.actionName ? meta.actionName : actionId;
          const roleName = meta && meta.roleName ? meta.roleName : roleId;
          datasetStatusEl.textContent = `Updated ${actionName} ↔ ${roleName}: ${displayLetters}`;
        }
      }


      function wrapText(textSelection, width, nodeHeight) {
        textSelection.each(function () {
          const text = d3.select(this);
          const words = (text.text() || "").split(/\s+/).filter(Boolean);
          if (!words.length) {
            return;
          }
          const x = text.attr("x");
          const y = text.attr("y");
          const lineHeight = 1.25;
          text.text(null);
          let line = [];
          let lineNumber = 0;
          let tspan = text.append("tspan").attr("x", x).attr("y", y).attr("dy", "0em");
          for (const word of words) {
            line.push(word);
            tspan.text(line.join(" "));
            if (tspan.node().getComputedTextLength() > width && line.length > 1) {
              line.pop();
              tspan.text(line.join(" "));
              line = [word];
              tspan = text
                .append("tspan")
                .attr("x", x)
                .attr("y", y)
                .attr("dy", `${++lineNumber * lineHeight}em`)
                .text(word);
            }
          }
          const lineCount = lineNumber + 1;
          const linePixelHeight = lineCount * lineHeight * 11;
          const offset = Math.max(0, (nodeHeight - linePixelHeight) / 2 - 2);
          text.attr("y", +y + offset);
          text.selectAll("tspan").attr("y", +y + offset);
        });
      }

      window.addEventListener("resize", () => {
        if (!cachedData) return;
        if (resizeTimeout) {
          clearTimeout(resizeTimeout);
        }
        resizeTimeout = setTimeout(() => {
          renderSankey(cachedData);
          renderDependencyGraph(cachedData);
          renderResponsibilityMatrix(cachedData);
        }, 200);
      });

      init();
    </script>
  </body>
</html>
